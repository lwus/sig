{"version":3,"sources":["utils/transactions.ts","contexts/ConnectionContext.tsx","utils/notifications.tsx","utils/borsh.ts","utils/programIds.ts","contexts/AccountContext.tsx","utils/eventEmitter.ts","utils/accounts.ts","components/Settings/index.tsx","App.tsx","components/Header/Header.tsx","utils/ids.ts","components/DefaultModal/index.tsx","contexts/WalletContext/WalletContext.tsx","contexts/WalletContext/wallet.less","contexts/ModalContext.tsx","contexts/ColorModeContext.tsx","reportWebVitals.ts","index.tsx","constants/math.ts","utils/utils.ts"],"names":["getUnixTs","Date","getTime","explorerLinkFor","txid","connection","match","_rpcEndpoint","envFor","sendSignedTransaction","a","signedTransaction","timeout","rawTransaction","serialize","startTime","slot","sendRawTransaction","skipPreflight","log","debug","done","sleep","awaitTransactionSignatureConfirmation","confirmation","Error","err","error","simulateResult","simulateTransaction","value","logs","i","length","line","startsWith","slice","JSON","stringify","transaction","commitment","_recentBlockhash","_disableBlockhashCaching","recentBlockhash","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","args","encoding","_rpcRequest","res","message","result","queryStatus","status","confirmations","subId","Promise","resolve","reject","setTimeout","warn","onSignature","context","e","getSignatureStatuses","signatureStatuses","console","_signatureSubscriptions","removeSignatureListener","ENDPOINTS","name","endpoint","ChainId","MainnetBeta","Devnet","DEFAULT","ConnectionContext","React","createContext","setEndpoint","Connection","env","tokens","tokenMap","Map","ConnectionProvider","children","undefined","useLocalStorageState","useMemo","find","end","useState","setTokens","setTokenMap","useEffect","TokenListProvider","then","container","list","excludeByTag","filterByChainId","getList","knownMints","reduce","map","item","set","address","id","onAccountChange","Keypair","generate","publicKey","removeAccountChangeListener","onSlotChange","removeSlotChangeListener","Provider","useConnection","useContext","useConnectionConfig","SequenceType","getErrorForTransaction","confirmTransaction","getParsedConfirmedTransaction","tx","errors","meta","logMessages","forEach","m","regex","exec","index","lastIndex","push","sendTransactionWithRetry","wallet","instructions","signers","includesFeePayer","block","beforeSend","WalletNotConnectedError","Transaction","instruction","add","getRecentBlockhash","blockhash","setSigners","s","partialSign","signTransaction","notify","description","type","placement","notification","style","color","opacity","backgroundColor","BinaryReader","prototype","readPubkey","array","this","readFixedArray","PublicKey","BinaryWriter","writePubkey","writeFixedArray","toBuffer","readPubkeyAsString","base58","encode","writePubkeyAsString","decode","programIds","token","TOKEN_PROGRAM_ID","associatedToken","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","bpf_upgrade_loader","BPF_UPGRADE_LOADER_ID","system","SYSTEM","memo","MEMO_ID","AccountsContext","pendingCalls","genericCache","pendingMintCalls","mintCache","getMintInfo","pubKey","getAccountInfo","info","data","Buffer","from","deserializeMint","TokenAccountParser","buffer","deserializeAccount","pubkey","account","keyToAccountParser","cache","emitter","EventEmitter","query","parser","toBase58","get","obj","isActive","deserialize","registerParser","delete","Function","isNew","has","raiseCacheUpdated","key","raiseCacheDeleted","byParser","keys","queryMint","mint","getMint","addMint","UseNativeAccount","useWallet","nativeAccount","setNativeAccount","updateCache","useCallback","wrapped","WRAPPED_SOL_MINT","owner","amount","u64","lamports","delegate","delegatedAmount","isInitialized","isFrozen","isNative","rentExemptReserve","closeAuthority","wrapNativeAccount","updateAccount","PRECACHED_OWNERS","Set","precacheUserTokenAccounts","getTokenAccountsByOwner","programId","AccountsProvider","tokenAccounts","setTokenAccounts","userAccounts","setUserAccounts","walletKey","selectUserAccounts","filter","accounts","subs","onCache","tokenSubID","onProgramAccountChange","accountId","accountInfo","AccountLayout","span","removeProgramAccountChangeListener","fromBuffer","delegateOption","state","isNativeOption","closeAuthorityOption","MintLayout","mintInfo","mintAuthorityOption","mintAuthority","supply","freezeAuthorityOption","freezeAuthority","CacheUpdateEvent","CacheDeleteEvent","MarketUpdateEvent","ids","Emitter","callback","on","removeListener","emit","getMetadata","findProgramAddress","TOKEN_METADATA_PROGRAM_ID","Settings","narrow","disconnect","setVisible","useWalletModal","open","setModal","useModal","theme","useTheme","colorModeCtx","useColorMode","handleConnect","ModalEnum","WALLET","connectedActions","click","navigator","clipboard","writeText","innerNarrow","shortenAddress","inner","Fragment","catch","expandedExtra","variant","drawerOpen","setDrawerOpen","envCollapseOpen","setEnvCollapseOpen","hackySkipSet","toggleDrawer","event","target","classList","contains","drawerC","onClick","anchor","onClose","sx","width","role","onKeyDown","themeSwitch","ml","toggleColorMode","palette","mode","listHead","primary","primaryTypographyProps","fontSize","fontWeight","letterSpacing","className","in","unmountOnExit","component","disablePadding","p","selected","pl","idx","direction","spacing","display","justifyContent","alignItems","marginRight","minWidth","onChange","underline","METADATA_SIGNATURE","signMetadataInstruction","metadata","creator","isSigner","isWritable","TransactionInstruction","About","mints","wrap","connected","ixs","signResult","getWindowDimensions","window","innerWidth","height","innerHeight","App","createTheme","windowDimensions","setWindowDimensions","handleResize","addEventListener","removeEventListener","useWindowDimensions","maxWidth","marginLeft","path","Header","bgcolor","overflow","flexGrow","CANDY_MACHINE_ID","DefaultModal","props","bodyStyle","closeIcon","rest","background","borderRadius","flexDirection","footer","WalletModalContext","WalletModal","wallets","select","visible","setShowWallets","close","onCancel","textAlign","verticalAlign","lineHeight","marginBottom","size","icon","alt","src","float","WalletModalProvider","setConnected","keyToDisplay","substring","WalletProvider","getPhantomWallet","getSolflareWallet","getTorusWallet","options","clientId","uxMode","getLedgerWallet","getSolongWallet","getMathWallet","getSolletWallet","onError","autoConnect","ModalContext","removeModal","ColorModeContext","ColorModeContextProvider","setMode","prevMode","reportWebVitals","onPerfEntry","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","TEN","BN","pow","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","defaultState","storedState","localStorage","getItem","parse","setState","setLocalStorageState","newState","removeItem","setItem","chars","chunks","Array","apply","Math","ceil","_","currency","ms"],"mappings":"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","file":"static/js/main.4dedc4b8.chunk.js","sourcesContent":["import {\n  Blockhash,\n  Commitment,\n  Connection,\n  FeeCalculator,\n  Keypair,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n} from '@solana/web3.js';\nimport { sleep } from \"../utils/utils\";\nimport log from 'loglevel';\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport const DEFAULT_TIMEOUT = 15000;\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nexport const envFor = (\n  connection: Connection\n) : string => {\n  const endpoint = (connection as any)._rpcEndpoint;\n  const regex = /https:\\/\\/api.([^.]*).solana.com/;\n  const match = endpoint.match(regex);\n  if (match[1]) {\n    return match[1];\n  }\n  return \"mainnet-beta\";\n}\n\nexport const explorerLinkFor = (\n  txid: TransactionSignature,\n  connection: Connection\n) : string => {\n  return `https://explorer.solana.com/tx/${txid}?cluster=${envFor(connection)}`;\n}\n\nexport const sendTransactionWithRetryWithKeypair = async (\n  connection: Connection,\n  wallet: Keypair,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void,\n) => {\n  const transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.sign(...[wallet, ...signers]);\n  } else {\n    transaction.sign(wallet);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const { txid, slot } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction,\n  });\n\n  return { txid, slot };\n};\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    },\n  );\n\n  log.debug('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      'confirmed',\n      true,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      log.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err) {\n    log.error('Timeout Error caught', err);\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {\n      log.error('Simulate Transaction error', e);\n    }\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n              'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  log.debug('Latency (ms)', txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment,\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config: any = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n\nexport async function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n  commitment: Commitment = 'recent',\n  queryStatus = false,\n): Promise<SignatureStatus | null | void> {\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  // eslint-disable-next-line no-async-promise-executor\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      log.warn('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            log.warn('Rejected via websocket', result.err);\n            reject(status);\n          } else {\n            log.debug('Resolved via websocket', result);\n            resolve(status);\n          }\n        },\n        commitment,\n      );\n    } catch (e) {\n      done = true;\n      log.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          console.log(explorerLinkFor(txid, connection));\n          if (!done) {\n            if (!status) {\n              log.debug('REST null result for', txid, status);\n            } else if (status.err) {\n              log.error('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              log.error('REST no confirmations for', txid, status);\n            } else {\n              log.debug('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            log.error('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  log.debug('Returning status', status);\n  return status;\n}\n","import { useLocalStorageState } from \"../utils/utils\";\nimport {\n  Keypair,\n  Commitment,\n  Connection,\n  Transaction,\n  TransactionInstruction,\n  Blockhash,\n  FeeCalculator,\n} from \"@solana/web3.js\";\nimport React, { useContext, useEffect, useMemo, useState } from \"react\";\nimport {\n  sendSignedTransaction,\n} from \"../utils/transactions\";\nimport {\n  TokenInfo,\n  TokenListProvider,\n  ENV as ChainId,\n} from \"@solana/spl-token-registry\";\nimport { WalletSigner } from \"./WalletContext/WalletContext\";\nimport { WalletNotConnectedError } from \"@solana/wallet-adapter-base\";\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport type ENV = \"mainnet-beta\" | \"testnet\" | \"devnet\" | \"localnet\";\n\nexport const ENDPOINTS = [\n  {\n    name: \"mainnet-beta\" as ENV,\n    endpoint: \"https://api.mainnet-beta.solana.com\",\n    ChainId: ChainId.MainnetBeta,\n  },\n  {\n    name: \"devnet\" as ENV,\n    endpoint: \"https://api.devnet.solana.com\",\n    ChainId: ChainId.Devnet,\n  },\n];\n\nconst DEFAULT = ENDPOINTS[0].endpoint;\n\ninterface ConnectionConfig {\n  connection: Connection;\n  endpoint: string;\n  env: ENV;\n  setEndpoint: (val: string) => void;\n  tokens: TokenInfo[];\n  tokenMap: Map<string, TokenInfo>;\n}\n\nconst ConnectionContext = React.createContext<ConnectionConfig>({\n  endpoint: DEFAULT,\n  setEndpoint: () => {},\n  connection: new Connection(DEFAULT, \"recent\"),\n  env: ENDPOINTS[0].name,\n  tokens: [],\n  tokenMap: new Map<string, TokenInfo>(),\n});\n\nexport function ConnectionProvider({ children = undefined as any }) {\n  const [endpoint, setEndpoint] = useLocalStorageState(\n    \"connectionEndpoint\",\n    ENDPOINTS[0].endpoint\n  );\n\n  const connection = useMemo(\n    () => new Connection(endpoint, \"recent\"),\n    [endpoint]\n  );\n\n  const env =\n    ENDPOINTS.find((end) => end.endpoint === endpoint)?.name ||\n    ENDPOINTS[0].name;\n\n  const [tokens, setTokens] = useState<TokenInfo[]>([]);\n  const [tokenMap, setTokenMap] = useState<Map<string, TokenInfo>>(new Map());\n  useEffect(() => {\n    // fetch token files\n    new TokenListProvider().resolve().then((container) => {\n      const list = container\n        .excludeByTag(\"nft\")\n        .filterByChainId(\n          ENDPOINTS.find((end) => end.endpoint === endpoint)?.ChainId ||\n            ChainId.MainnetBeta\n        )\n        .getList();\n\n      const knownMints = [...list].reduce((map, item) => {\n        map.set(item.address, item);\n        return map;\n      }, new Map<string, TokenInfo>());\n\n      setTokenMap(knownMints);\n      setTokens(list);\n    });\n  }, [env, endpoint]);\n\n  // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n  useEffect(() => {\n    const id = connection.onAccountChange(\n      Keypair.generate().publicKey,\n      () => {}\n    );\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n\n  return (\n    <ConnectionContext.Provider\n      value={{\n        endpoint,\n        setEndpoint,\n        connection,\n        tokens,\n        tokenMap,\n        env,\n      }}\n    >\n      {children}\n    </ConnectionContext.Provider>\n  );\n}\n\nexport function useConnection() {\n  return useContext(ConnectionContext).connection as Connection;\n}\n\nexport function useConnectionConfig() {\n  const context = useContext(ConnectionContext);\n  return {\n    endpoint: context.endpoint,\n    setEndpoint: context.setEndpoint,\n    env: context.env,\n    tokens: context.tokens,\n    tokenMap: context.tokenMap,\n  };\n}\n\nexport const getErrorForTransaction = async (\n  connection: Connection,\n  txid: string\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, \"max\");\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach((log) => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport const sendTransactionWithRetry = async (\n  connection: Connection,\n  wallet: WalletSigner,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = \"singleGossip\",\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void\n) : Promise<string| { txid: string; slot: number }> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach((instruction) => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map((s) => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey)\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    try {\n      transaction = await wallet.signTransaction(transaction);\n    } catch {\n      return \"Failed to sign transaction\";\n    }\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n  console.log(\"About to send\");\n  try {\n    const { txid, slot } = await sendSignedTransaction({\n      connection,\n      signedTransaction: transaction,\n    });\n\n    return { txid, slot };\n  } catch (error) {\n    console.error(error);\n    return \"See console logs\";\n  }\n};\n\n","import React from 'react';\nimport { notification } from 'antd';\n// import Link from '../components/Link';\n\nexport function notify({\n  message = '',\n  description = undefined as any,\n  txid = '',\n  type = 'info',\n  placement = 'bottomLeft',\n}) {\n  if (txid) {\n    //   <Link\n    //     external\n    //     to={'https://explorer.solana.com/tx/' + txid}\n    //     style={{ color: '#0000ff' }}\n    //   >\n    //     View transaction {txid.slice(0, 8)}...{txid.slice(txid.length - 8)}\n    //   </Link>\n\n    description = <></>;\n  }\n  (notification as any)[type]({\n    message: <span style={{ color: 'black' }}>{message}</span>,\n    description: (\n      <span style={{ color: 'black', opacity: 0.5 }}>{description}</span>\n    ),\n    placement,\n    style: {\n      backgroundColor: 'white',\n    },\n  });\n}\n","import { PublicKey } from '@solana/web3.js';\nimport { BinaryReader, BinaryWriter } from 'borsh';\nimport base58 from 'bs58';\nimport { StringPublicKey } from './ids';\n\nexport const extendBorsh = () => {\n  (BinaryReader.prototype as any).readPubkey = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return new PublicKey(array);\n  };\n\n  (BinaryWriter.prototype as any).writePubkey = function (value: PublicKey) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(value.toBuffer());\n  };\n\n  (BinaryReader.prototype as any).readPubkeyAsString = function () {\n    const reader = this as unknown as BinaryReader;\n    const array = reader.readFixedArray(32);\n    return base58.encode(array) as StringPublicKey;\n  };\n\n  (BinaryWriter.prototype as any).writePubkeyAsString = function (\n    value: StringPublicKey,\n  ) {\n    const writer = this as unknown as BinaryWriter;\n    writer.writeFixedArray(base58.decode(value));\n  };\n};\n\nextendBorsh();\n","import {\n  TOKEN_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  BPF_UPGRADE_LOADER_ID,\n  SYSTEM,\n  MEMO_ID,\n} from './ids';\n\nexport const setProgramIds = async () => {};\n\nexport const programIds = () => {\n  return {\n    token: TOKEN_PROGRAM_ID,\n    associatedToken: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    bpf_upgrade_loader: BPF_UPGRADE_LOADER_ID,\n    system: SYSTEM,\n    memo: MEMO_ID,\n    // store: STORE,\n  };\n};\n","import React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useState,\n} from 'react';\nimport { useConnection } from './ConnectionContext';\nimport { useWallet } from '@solana/wallet-adapter-react';\nimport { AccountInfo, Connection, PublicKey } from '@solana/web3.js';\nimport { AccountLayout, MintInfo, MintLayout, u64 } from '@solana/spl-token';\nimport { TokenAccount } from '../models';\nimport { chunks } from '../utils/utils';\nimport { EventEmitter } from '../utils/eventEmitter';\nimport { StringPublicKey, WRAPPED_SOL_MINT } from '../utils/ids';\nimport { programIds } from '../utils/programIds';\n\nconst AccountsContext = React.createContext<any>(null);\n\nconst pendingCalls = new Map<string, Promise<ParsedAccountBase>>();\nconst genericCache = new Map<string, ParsedAccountBase>();\nconst pendingMintCalls = new Map<string, Promise<MintInfo>>();\nconst mintCache = new Map<string, MintInfo>();\n\nexport interface ParsedAccountBase {\n  pubkey: StringPublicKey;\n  account: AccountInfo<Buffer>;\n  info: any; // TODO: change to unknown\n}\n\nexport type AccountParser = (\n  pubkey: StringPublicKey,\n  data: AccountInfo<Buffer>,\n) => ParsedAccountBase | undefined;\n\nexport interface ParsedAccount<T> extends ParsedAccountBase {\n  info: T;\n}\n\nconst getMintInfo = async (connection: Connection, pubKey: PublicKey) => {\n  const info = await connection.getAccountInfo(pubKey);\n  if (info === null) {\n    throw new Error('Failed to find mint account');\n  }\n\n  const data = Buffer.from(info.data);\n\n  return deserializeMint(data);\n};\n\nexport const MintParser = (pubKey: string, info: AccountInfo<Buffer>) => {\n  const buffer = Buffer.from(info.data);\n\n  const data = deserializeMint(buffer);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: data,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const TokenAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  // Sometimes a wrapped sol account gets closed, goes to 0 length,\n  // triggers an update over wss which triggers this guy to get called\n  // since your UI already logged that pubkey as a token account. Check for length.\n  if (info.data.length > 0) {\n    const buffer = Buffer.from(info.data);\n    const data = deserializeAccount(buffer);\n\n    const details = {\n      pubkey: pubKey,\n      account: {\n        ...info,\n      },\n      info: data,\n    } as TokenAccount;\n\n    return details;\n  }\n};\n\nexport const GenericAccountParser = (\n  pubKey: string,\n  info: AccountInfo<Buffer>,\n) => {\n  const buffer = Buffer.from(info.data);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: buffer,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const keyToAccountParser = new Map<string, AccountParser>();\n\nexport const cache = {\n  emitter: new EventEmitter(),\n  query: async (\n    connection: Connection,\n    pubKey: string | PublicKey,\n    parser?: AccountParser,\n  ) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n\n    let account = genericCache.get(address);\n    if (account) {\n      return account;\n    }\n\n    let query = pendingCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    // TODO: refactor to use multiple accounts query with flush like behavior\n    query = connection.getAccountInfo(id).then(data => {\n      if (!data) {\n        throw new Error('Account not found');\n      }\n\n      return cache.add(id, data, parser);\n    }) as Promise<TokenAccount>;\n    pendingCalls.set(address, query as any);\n\n    return query;\n  },\n  add: (\n    id: PublicKey | string,\n    obj: AccountInfo<Buffer>,\n    parser?: AccountParser,\n    isActive?: boolean | undefined | ((parsed: any) => boolean),\n  ) => {\n    const address = typeof id === 'string' ? id : id?.toBase58();\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\n    if (!deserialize) {\n      throw new Error(\n        'Deserializer needs to be registered or passed as a parameter',\n      );\n    }\n\n    cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    const account = deserialize(address, obj);\n    if (!account) {\n      return;\n    }\n\n    if (isActive === undefined) isActive = true;\n    else if (isActive instanceof Function) isActive = isActive(account);\n\n    const isNew = !genericCache.has(address);\n\n    genericCache.set(address, account);\n    cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);\n    return account;\n  },\n  get: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return genericCache.get(key);\n  },\n  delete: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    if (genericCache.get(key)) {\n      genericCache.delete(key);\n      cache.emitter.raiseCacheDeleted(key);\n      return true;\n    }\n    return false;\n  },\n\n  byParser: (parser: AccountParser) => {\n    const result: string[] = [];\n    for (const id of keyToAccountParser.keys()) {\n      if (keyToAccountParser.get(id) === parser) {\n        result.push(id);\n      }\n    }\n\n    return result;\n  },\n  registerParser: (pubkey: PublicKey | string, parser: AccountParser) => {\n    if (pubkey) {\n      const address = typeof pubkey === 'string' ? pubkey : pubkey?.toBase58();\n      keyToAccountParser.set(address, parser);\n    }\n\n    return pubkey;\n  },\n  queryMint: async (connection: Connection, pubKey: string | PublicKey) => {\n    let id: PublicKey;\n    if (typeof pubKey === 'string') {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    let mint = mintCache.get(address);\n    if (mint) {\n      return mint;\n    }\n\n    let query = pendingMintCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    query = getMintInfo(connection, id).then(data => {\n      pendingMintCalls.delete(address);\n\n      mintCache.set(address, data);\n      return data;\n    }) as Promise<MintInfo>;\n    pendingMintCalls.set(address, query as any);\n\n    return query;\n  },\n  getMint: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return mintCache.get(key);\n  },\n  addMint: (pubKey: PublicKey, obj: AccountInfo<Buffer>) => {\n    const mint = deserializeMint(obj.data);\n    const id = pubKey.toBase58();\n    mintCache.set(id, mint);\n    return mint;\n  },\n};\n\nexport const useAccountsContext = () => {\n  const context = useContext(AccountsContext);\n\n  return context;\n};\n\nfunction wrapNativeAccount(\n  pubkey: string,\n  account?: AccountInfo<Buffer>,\n): TokenAccount | undefined {\n  if (!account) {\n    return undefined;\n  }\n\n  const key = new PublicKey(pubkey);\n\n  return {\n    pubkey: pubkey,\n    account,\n    info: {\n      address: key,\n      mint: WRAPPED_SOL_MINT,\n      owner: key,\n      amount: new u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null,\n    },\n  };\n}\n\nexport const getCachedAccount = (\n  predicate: (account: TokenAccount) => boolean,\n) => {\n  for (const account of genericCache.values()) {\n    if (predicate(account)) {\n      return account as TokenAccount;\n    }\n  }\n};\n\nconst UseNativeAccount = () => {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n\n  const [nativeAccount, setNativeAccount] = useState<AccountInfo<Buffer>>();\n\n  const updateCache = useCallback(\n    account => {\n      if (publicKey) {\n        const wrapped = wrapNativeAccount(publicKey.toBase58(), account);\n        if (wrapped !== undefined) {\n          const id = publicKey.toBase58();\n          cache.registerParser(id, TokenAccountParser);\n          genericCache.set(id, wrapped as TokenAccount);\n          cache.emitter.raiseCacheUpdated(id, false, TokenAccountParser, true);\n        }\n      }\n    },\n    [publicKey],\n  );\n\n  useEffect(() => {\n    let subId = 0;\n    const updateAccount = (account: AccountInfo<Buffer> | null) => {\n      if (account) {\n        updateCache(account);\n        setNativeAccount(account);\n      }\n    };\n\n    (async () => {\n      if (!connection || !publicKey) {\n        return;\n      }\n\n      try {\n        const account = await connection.getAccountInfo(publicKey);\n        updateAccount(account);\n      } catch {\n        return;\n      }\n\n      subId = connection.onAccountChange(publicKey, updateAccount);\n    })();\n\n    return () => {\n      if (subId) {\n        connection.removeAccountChangeListener(subId);\n      }\n    };\n  }, [setNativeAccount, publicKey, connection, updateCache]);\n\n  return { nativeAccount };\n};\n\nconst PRECACHED_OWNERS = new Set<string>();\nconst precacheUserTokenAccounts = async (\n  connection: Connection,\n  owner?: PublicKey,\n) => {\n  if (!owner) {\n    return;\n  }\n\n  // used for filtering account updates over websocket\n  PRECACHED_OWNERS.add(owner.toBase58());\n\n  // user accounts are updated via ws subscription\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\n    programId: programIds().token,\n  });\n\n  accounts.value.forEach(info => {\n    cache.add(info.pubkey.toBase58(), info.account, TokenAccountParser);\n  });\n};\n\nexport function AccountsProvider({ children = null as any }) {\n  const connection = useConnection();\n  const { publicKey } = useWallet();\n  const [tokenAccounts, setTokenAccounts] = useState<TokenAccount[]>([]);\n  const [userAccounts, setUserAccounts] = useState<TokenAccount[]>([]);\n  const { nativeAccount } = UseNativeAccount();\n  const walletKey = publicKey?.toBase58();\n\n  const selectUserAccounts = useCallback(() => {\n    return cache\n      .byParser(TokenAccountParser)\n      .map(id => cache.get(id))\n      .filter(a => a && a.info.owner.toBase58() === walletKey)\n      .map(a => a as TokenAccount);\n  }, [walletKey]);\n\n  useEffect(() => {\n    const accounts = selectUserAccounts().filter(\n      a => a !== undefined,\n    ) as TokenAccount[];\n    setUserAccounts(accounts);\n  }, [nativeAccount, tokenAccounts, selectUserAccounts]);\n\n  useEffect(() => {\n    const subs: number[] = [];\n    cache.emitter.onCache(args => {\n      if (args.isNew && args.isActive) {\n        let id = args.id;\n        let deserialize = args.parser;\n        connection.onAccountChange(new PublicKey(id), info => {\n          cache.add(id, info, deserialize);\n        });\n      }\n    });\n\n    return () => {\n      subs.forEach(id => connection.removeAccountChangeListener(id));\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    if (!connection || !publicKey) {\n      setTokenAccounts([]);\n    } else {\n      precacheUserTokenAccounts(connection, publicKey).then(() => {\n        setTokenAccounts(selectUserAccounts());\n      });\n\n      // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter.\n      // this should use only filter syntax to only get accounts that are owned by user\n      const tokenSubID = connection.onProgramAccountChange(\n        programIds().token,\n        info => {\n          // TODO: fix type in web3.js\n          const id = info.accountId as unknown as string;\n          // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n          if (info.accountInfo.data.length === AccountLayout.span) {\n            const data = deserializeAccount(info.accountInfo.data);\n\n            if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\n              cache.add(id, info.accountInfo, TokenAccountParser);\n              setTokenAccounts(selectUserAccounts());\n            }\n          }\n        },\n        'singleGossip',\n      );\n\n      return () => {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, publicKey, selectUserAccounts]);\n\n  return (\n    <AccountsContext.Provider\n      value={{\n        userAccounts,\n        nativeAccount,\n      }}\n    >\n      {children}\n    </AccountsContext.Provider>\n  );\n}\n\nexport function useNativeAccount() {\n  const context = useContext(AccountsContext);\n  return {\n    account: context.nativeAccount as AccountInfo<Buffer>,\n  };\n}\n\nexport const getMultipleAccounts = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const result = await Promise.all(\n    chunks(keys, 99).map(chunk =>\n      getMultipleAccountsCore(connection, chunk, commitment),\n    ),\n  );\n\n  const array = result\n    .map(\n      a =>\n        a.array.map(acc => {\n          if (!acc) {\n            return undefined;\n          }\n\n          const { data, ...rest } = acc;\n          const obj = {\n            ...rest,\n            data: Buffer.from(data[0], 'base64'),\n          } as AccountInfo<Buffer>;\n          return obj;\n        }) as AccountInfo<Buffer>[],\n    )\n    .flat();\n  return { keys, array };\n};\n\nconst getMultipleAccountsCore = async (\n  connection: any,\n  keys: string[],\n  commitment: string,\n) => {\n  const args = connection._buildArgs([keys], commitment, 'base64');\n\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\n  if (unsafeRes.error) {\n    throw new Error(\n      'failed to get info about account ' + unsafeRes.error.message,\n    );\n  }\n\n  if (unsafeRes.result.value) {\n    const array = unsafeRes.result.value as AccountInfo<string[]>[];\n    return { keys, array };\n  }\n\n  // TODO: fix\n  throw new Error();\n};\n\nexport function useMint(key?: string | PublicKey) {\n  const connection = useConnection();\n  const [mint, setMint] = useState<MintInfo>();\n\n  const id = typeof key === 'string' ? key : key?.toBase58();\n\n  useEffect(() => {\n    if (!id) {\n      return;\n    }\n\n    cache\n      .query(connection, id, MintParser)\n      .then(acc => setMint(acc.info as any))\n      .catch(err => console.log(err));\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === id) {\n        cache\n          .query(connection, id, MintParser)\n          .then(mint => setMint(mint.info as any));\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, id]);\n\n  return mint;\n}\n\nexport function useAccount(pubKey?: PublicKey) {\n  const connection = useConnection();\n  const [account, setAccount] = useState<TokenAccount>();\n\n  const key = pubKey?.toBase58();\n  useEffect(() => {\n    const query = async () => {\n      try {\n        if (!key) {\n          return;\n        }\n\n        const acc = await cache\n          .query(connection, key, TokenAccountParser)\n          .catch(err => console.log(err));\n        if (acc) {\n          setAccount(acc);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    query();\n\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n      if (event.id === key) {\n        query();\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, key]);\n\n  return account;\n}\n\n// TODO: expose in spl package\nexport const deserializeAccount = (data: Buffer) => {\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n};\n\n// TODO: expose in spl package\nexport const deserializeMint = (data: Buffer) => {\n  if (data.length !== MintLayout.span) {\n    throw new Error('Not a valid Mint');\n  }\n\n  const mintInfo = MintLayout.decode(data);\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo as MintInfo;\n};\n","import { EventEmitter as Emitter } from 'eventemitter3';\n\nexport class CacheUpdateEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  parser: any;\n  isNew: boolean;\n  isActive: boolean;\n  constructor(id: string, isNew: boolean, parser: any, isActive: boolean) {\n    this.id = id;\n    this.parser = parser;\n    this.isNew = isNew;\n    this.isActive = isActive;\n  }\n}\n\nexport class CacheDeleteEvent {\n  static type = 'CacheUpdate';\n  id: string;\n  constructor(id: string) {\n    this.id = id;\n  }\n}\n\nexport class MarketUpdateEvent {\n  static type = 'MarketUpdate';\n  ids: Set<string>;\n  constructor(ids: Set<string>) {\n    this.ids = ids;\n  }\n}\n\nexport class EventEmitter {\n  private emitter = new Emitter();\n\n  onMarket(callback: (args: MarketUpdateEvent) => void) {\n    this.emitter.on(MarketUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(MarketUpdateEvent.type, callback);\n  }\n\n  onCache(callback: (args: CacheUpdateEvent) => void) {\n    this.emitter.on(CacheUpdateEvent.type, callback);\n\n    return () => this.emitter.removeListener(CacheUpdateEvent.type, callback);\n  }\n\n  raiseMarketUpdated(ids: Set<string>) {\n    this.emitter.emit(MarketUpdateEvent.type, new MarketUpdateEvent(ids));\n  }\n\n  raiseCacheUpdated(\n    id: string,\n    isNew: boolean,\n    parser: any,\n    isActive: boolean,\n  ) {\n    this.emitter.emit(\n      CacheUpdateEvent.type,\n      new CacheUpdateEvent(id, isNew, parser, isActive),\n    );\n  }\n\n  raiseCacheDeleted(id: string) {\n    this.emitter.emit(CacheDeleteEvent.type, new CacheDeleteEvent(id));\n  }\n}\n","import * as anchor from '@project-serum/anchor';\nimport { Connection, PublicKey } from '@solana/web3.js';\nimport {\n  AccountLayout,\n  MintInfo,\n  MintLayout,\n} from \"@solana/spl-token\";\nimport BN from 'bn.js';\n\nimport {\n  CANDY_MACHINE_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  TOKEN_METADATA_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n} from \"./ids\";\n\nexport const getMintInfo = async (\n  connection : Connection,\n  mint : string\n) : Promise<{ key: PublicKey, info: MintInfo }> => {\n  let mintKey : PublicKey;\n  try {\n    mintKey = new PublicKey(mint);\n  } catch (err) {\n    throw new Error(`Invalid mint key ${err}`);\n  }\n  const mintAccount = await connection.getAccountInfo(mintKey);\n  if (mintAccount === null) {\n    throw new Error(`Could not fetch mint`);\n  }\n  if (!mintAccount.owner.equals(TOKEN_PROGRAM_ID)) {\n    const mintOwner = mintAccount.owner.toBase58();\n    throw new Error(`Invalid mint owner ${mintOwner}`);\n  }\n  if (mintAccount.data.length !== MintLayout.span) {\n    throw new Error(`Invalid mint size ${mintAccount.data.length}`);\n  }\n  const mintInfo = MintLayout.decode(Buffer.from(mintAccount.data));\n  return {\n    key: mintKey,\n    info: mintInfo,\n  };\n};\n\nexport const getCreatorTokenAccount = async (\n  walletKey : PublicKey,\n  connection : Connection,\n  mintKey : PublicKey,\n  totalClaim : number,\n) => {\n  const [creatorTokenKey, ] = await PublicKey.findProgramAddress(\n    [\n      walletKey.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      mintKey.toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n  const creatorTokenAccount = await connection.getAccountInfo(creatorTokenKey);\n  if (creatorTokenAccount === null) {\n    throw new Error(`Could not fetch creator token account`);\n  }\n  if (creatorTokenAccount.data.length !== AccountLayout.span) {\n    throw new Error(`Invalid token account size ${creatorTokenAccount.data.length}`);\n  }\n  const creatorTokenInfo = AccountLayout.decode(Buffer.from(creatorTokenAccount.data));\n  if (new BN(creatorTokenInfo.amount, 8, \"le\").toNumber() < totalClaim) {\n    throw new Error(`Creator token account does not have enough tokens`);\n  }\n  return creatorTokenKey;\n};\n\nexport const fetchCoder = async (\n  address : anchor.Address,\n  connection : Connection,\n) : Promise<anchor.Coder | null> => {\n  return new anchor.Coder(await anchor.Program.fetchIdl(\n      address, { connection: connection } as anchor.Provider));\n}\n\nexport const getCandyConfig = async (\n  connection : Connection,\n  config : string\n) : Promise<PublicKey> => {\n  let configKey : PublicKey;\n  try {\n    configKey = new PublicKey(config);\n  } catch (err) {\n    throw new Error(`Invalid config key ${err}`);\n  }\n  const configAccount = await connection.getAccountInfo(configKey);\n  if (configAccount === null) {\n    throw new Error(`Could not fetch config`);\n  }\n  if (!configAccount.owner.equals(CANDY_MACHINE_ID)) {\n    throw new Error(`Invalid config owner ${configAccount.owner.toBase58()}`);\n  }\n  return configKey;\n};\n\nexport const getCandyMachineAddress = async (\n  config: PublicKey,\n  uuid: string,\n) => {\n  return await PublicKey.findProgramAddress(\n    [Buffer.from(\"candy_machine\"), config.toBuffer(), Buffer.from(uuid)],\n    CANDY_MACHINE_ID,\n  );\n};\n\nexport const getCandyMachine = async (\n  connection : Connection,\n  candyMachineKey : PublicKey,\n) => {\n  const candyMachineCoder = await fetchCoder(CANDY_MACHINE_ID, connection);\n  if (candyMachineCoder === null) {\n    throw new Error(`Could not fetch candy machine IDL`);\n  }\n  const candyMachineAccount = await connection.getAccountInfo(candyMachineKey);\n  if (candyMachineAccount === null) {\n    throw new Error(`Could not fetch candy machine`);\n  }\n  return candyMachineCoder.accounts.decode(\n      \"CandyMachine\", candyMachineAccount.data);\n}\n\nexport const getMetadata = async (\n  mint: PublicKey,\n): Promise<PublicKey> => {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getEdition = async (\n  mint: PublicKey,\n): Promise<PublicKey> => {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getEditionMarkerPda = async (\n  mint: PublicKey,\n  edition: BN,\n) : Promise<PublicKey> => {\n  // editions are divided into pages of 31-bytes (248-bits) for more efficient\n  // packing to check if an edition is occupied. The offset is determined from\n  // the edition passed in through data\n  const editionPageNumber = edition.div(new BN(248)).toNumber();\n\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n        Buffer.from(String(editionPageNumber)),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n}\n","import React from \"react\";\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { ENDPOINTS, useColorMode, useConnectionConfig } from \"../../contexts\";\nimport { notify, shortenAddress } from \"../../utils\";\nimport { CopyOutlined } from \"@ant-design/icons\";\nimport { ModalEnum, useModal, useWalletModal } from \"../../contexts\";\nimport {\n  Box,\n  Button,\n  Collapse,\n  Divider,\n  Drawer,\n  FormControl,\n  Link,\n  List,\n  ListItem,\n  ListItemText,\n  ListItemButton,\n  MenuItem,\n  Select,\n  Stack,\n} from \"@mui/material\";\nimport { useTheme } from \"@mui/material/styles\";\n\nimport AccountBalanceWalletIcon from '@mui/icons-material/AccountBalanceWallet';\nimport Brightness4Icon from \"@mui/icons-material/Brightness4\";\nimport Brightness7Icon from \"@mui/icons-material/Brightness7\";\nimport ExpandLess from '@mui/icons-material/ExpandLess';\nimport ExpandMore from '@mui/icons-material/ExpandMore';\n\nexport const Settings = ({ narrow }) => {\n  const { disconnect, publicKey } = useWallet();\n  const { setEndpoint, env, endpoint } = useConnectionConfig();\n  const { setVisible } = useWalletModal();\n  const open = React.useCallback(() => setVisible(true), [setVisible]);\n  const { setModal } = useModal();\n  const theme = useTheme();\n  const colorModeCtx = useColorMode();\n\n  const handleConnect = React.useCallback(() => {\n    setModal(ModalEnum.WALLET);\n    setVisible(true);\n  }, [setModal, setVisible]);\n\n  const connectedActions = [\n    {\n      click: async () => {\n        if (publicKey) {\n          await navigator.clipboard.writeText(publicKey.toBase58());\n          notify({\n            message: \"Wallet update\",\n            description: \"Address copied to clipboard\",\n          });\n        }\n      },\n      innerNarrow: () => (\n        `Copy Address (${publicKey && shortenAddress(publicKey.toBase58())})`\n      ),\n      inner: () => (\n        <React.Fragment>\n          <CopyOutlined />\n          {publicKey && shortenAddress(publicKey.toBase58())}\n        </React.Fragment>\n      ),\n    },\n    {\n      click: open,\n      inner: () => \"Change\\u00A0Wallet\",\n    },\n    {\n      click: () => disconnect().catch(),\n      inner: () => `Disconnect\\u00A0(${env})`,\n      expandedExtra: { // these are interepreted as props. TODO: specific types\n        color: \"error\" as any,\n        variant: \"contained\" as any,\n      }\n    },\n  ];\n\n  const [drawerOpen, setDrawerOpen] = React.useState(false);\n  const [envCollapseOpen, setEnvCollapseOpen] = React.useState(false);\n\n  const hackySkipSet = \"hackySkipSet\";\n  const toggleDrawer = (open) => (event) => {\n    if (event.type === 'keydown' && (event.key === 'Tab' || event.key === 'Shift')) {\n      return;\n    }\n\n    if (event.target.classList.contains(hackySkipSet)) {\n      return;\n    }\n\n    setDrawerOpen(open);\n  };\n\n  const drawerC = (inner) => {\n    return (\n      <React.Fragment>\n        <Button onClick={toggleDrawer(true)}>\n          <AccountBalanceWalletIcon />\n        </Button>\n        <Drawer\n          anchor=\"right\"\n          open={drawerOpen}\n          onClose={toggleDrawer(false)}\n        >\n          <Box\n            sx={{ width: 250 }}\n            role=\"presentation\"\n            onClick={toggleDrawer(false)}\n            onKeyDown={toggleDrawer(false)}\n          >\n            {inner}\n          </Box>\n        </Drawer>\n      </React.Fragment>\n    );\n  };\n\n  const themeSwitch = (\n    <Button\n      sx={{ ml: 1 }}\n      onClick={colorModeCtx.toggleColorMode}\n      color=\"inherit\"\n    >\n      {theme.palette.mode === \"dark\" ? (\n        <Brightness7Icon />\n      ) : (\n        <Brightness4Icon />\n      )}\n    </Button>\n  );\n\n  if (narrow) {\n    const listHead = (\n      <ListItem>\n        <ListItemText\n          primary=\"Wallet\"\n          primaryTypographyProps={{\n            fontSize: \"1.2rem\",\n            fontWeight: 'medium',\n            letterSpacing: 0,\n          }}\n        />\n      </ListItem>\n    );\n    return (\n      <React.Fragment>\n        {!publicKey && drawerC(\n          <List>\n            {listHead}\n            <Divider />\n            <ListItemButton\n              onClick={() => setEnvCollapseOpen(!envCollapseOpen)}\n              className={hackySkipSet}\n            >\n              Change Network\n              {envCollapseOpen ? <ExpandLess /> : <ExpandMore />}\n            </ListItemButton>\n            <Collapse in={envCollapseOpen} timeout=\"auto\" unmountOnExit>\n              <List component=\"div\" disablePadding>\n                {ENDPOINTS.map(p => (\n                  <ListItemButton\n                    selected={endpoint === p.endpoint}\n                    onClick={() => setEndpoint(p.endpoint)}\n                    key={p.name}\n                    sx={{ pl: 4 }}\n                    className={hackySkipSet}\n                  >\n                    {p.name}\n                  </ListItemButton>\n                ))}\n              </List>\n            </Collapse>\n            <ListItemButton onClick={handleConnect}>\n              Connect\n            </ListItemButton>\n          </List>\n        )}\n        {publicKey && drawerC(\n          <List>\n            {listHead}\n            <Divider />\n            {connectedActions.map((a, idx) => {\n              return (\n                <ListItemButton onClick={a.click} key={idx}>\n                  {(a.innerNarrow && a.innerNarrow()) || a.inner()}\n                </ListItemButton>\n              );\n            })}\n          </List>\n        )}\n        {themeSwitch}\n      </React.Fragment>\n    );\n  } else {\n    return (\n      <Stack\n        direction=\"row\"\n        spacing={2}\n        sx={{\n          display: \"flex\",\n          justifyContent: \"flex-end\",\n          alignItems: \"center\",\n          marginRight: \"36px\",\n        }}\n      >\n        {!publicKey && (\n          <React.Fragment>\n            <FormControl variant=\"standard\" style={{minWidth: \"10ch\"}}>\n              <Select\n                id=\"connected-env-select\"\n                onChange={(e) => { setEndpoint(e.target.value); }}\n                value={endpoint}\n              >\n                {ENDPOINTS.map(({ name, endpoint }) => (\n                  <MenuItem key={name} value={endpoint}>{name}</MenuItem>\n                ))}\n              </Select>\n            </FormControl>\n            <Link underline=\"none\">\n              <Button\n                variant=\"contained\"\n                onClick={handleConnect}\n              >\n                Connect\n              </Button>\n            </Link>\n          </React.Fragment>\n        )}\n        {publicKey && connectedActions.map((a, idx) => {\n            return (\n              <Button\n                key={idx}\n                variant=\"outlined\"\n                onClick={a.click}\n                {...a.expandedExtra}\n              >\n                {a.inner()}\n              </Button>\n            );\n          })\n        }\n        {themeSwitch}\n      </Stack>\n    );\n  }\n};\n","import React from \"react\";\nimport {\n  BrowserRouter,\n  Link,\n  Route,\n  Switch,\n} from \"react-router-dom\";\n\nimport { createTheme, ThemeProvider } from \"@mui/material/styles\";\nimport CssBaseline from \"@mui/material/CssBaseline\";\nimport {\n  Box,\n  Button,\n  Link as HyperLink,\n  Stack,\n} from \"@mui/material\";\n\nimport \"./App.css\";\n\nimport {\n  useColorMode,\n  useConnection,\n  Connection,\n} from \"./contexts\";\nimport { Header } from \"./components/Header/Header\";\nimport {\n  useWallet,\n} from \"@solana/wallet-adapter-react\";\n\nimport { Keypair, PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { getMetadata } from './utils/accounts';\nimport { TOKEN_METADATA_PROGRAM_ID } from './utils/ids';\nimport { sendTransactionWithRetryWithKeypair } from './utils/transactions';\n\nconst METADATA_SIGNATURE = Buffer.from([7]); //now thats some voodoo magic. WTF metaplex? XD\n\nexport function signMetadataInstruction(\n  metadata: PublicKey,\n  creator: PublicKey,\n): TransactionInstruction {\n  const data = METADATA_SIGNATURE;\n\n  const keys = [\n    {\n      pubkey: metadata,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: creator,\n      isSigner: true,\n      isWritable: false,\n    },\n  ];\n  return new TransactionInstruction({\n    keys,\n    programId: TOKEN_METADATA_PROGRAM_ID,\n    data,\n  });\n}\n\nconst About = () => {\n  const connection = useConnection();\n  const wallet = useWallet();\n  const mints = [ // TODO: metadata link to find editions remaining\n    new PublicKey(\"J8nLE658PUcLGU6qecatWweutttC9yofxF4UTeYutUXj\"),\n  ];\n  return (\n    <Button\n      onClick={() => {\n        const wrap = async () => {\n          if (!wallet.connected || wallet.publicKey === null) return;\n          try {\n            const ixs : Array<TransactionInstruction> = [];\n            for (const mint of mints) {\n              const metadata = await getMetadata(mint);\n              ixs.push(signMetadataInstruction(metadata, wallet.publicKey));\n            }\n            console.log(ixs);\n\n            const signResult = await Connection.sendTransactionWithRetry(\n              connection,\n              wallet,\n              ixs,\n              []\n            );\n            console.log(signResult);\n          } catch (err) {\n            console.error(err);\n          }\n        }\n        wrap();\n      }}\n    >\n      Click Me\n    </Button>\n  );\n};\n\nconst getWindowDimensions = () => {\n  const { innerWidth: width, innerHeight: height } = window;\n  return {\n    width,\n    height,\n  };\n};\n\n// eslint-disable-next-line\nconst useWindowDimensions = () => {\n  const [windowDimensions, setWindowDimensions] = React.useState(\n    getWindowDimensions()\n  );\n\n  React.useEffect(() => {\n    const handleResize = () => {\n      setWindowDimensions(getWindowDimensions());\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  return windowDimensions;\n};\n\nfunction App() {\n  const colorModeCtx = useColorMode();\n\n  React.useEffect(() => {}, [colorModeCtx.mode]);\n\n  const theme = React.useMemo(\n    () => {\n      let mode;\n      if (colorModeCtx.mode === \"dark\" || !colorModeCtx.mode) {\n        mode = \"dark\";\n      } else {\n        mode = \"light\";\n      }\n\n      return createTheme({\n        palette: {\n          mode,\n        },\n      })\n    },\n    [colorModeCtx.mode]\n  );\n\n  const { width } = useWindowDimensions();\n\n  return (\n    <div className=\"App\" style={{ backgroundColor: \"transparent\" }}>\n      <ThemeProvider theme={theme}>\n        <BrowserRouter>\n          <CssBaseline />\n          <Header narrow={width < 670}/>\n          <Box\n            maxWidth=\"60ch\"\n            width=\"calc(100% - 60px)\"\n            style={{\n              marginLeft: \"auto\",\n              marginRight: \"auto\",\n            }}\n          >\n            <Box height=\"40px\" />\n            <Switch>\n              <Route path=\"/sig/\" component={About} />\n            </Switch>\n            <Box height=\"80px\" />\n          </Box>\n        </BrowserRouter>\n      </ThemeProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport {\n  Link,\n} from \"react-router-dom\";\nimport {\n  Box,\n  Button,\n  Divider,\n  Drawer,\n  List,\n  ListItem,\n  ListItemButton,\n  ListItemText,\n  Stack,\n} from \"@mui/material\";\nimport HomeIcon from '@mui/icons-material/Home';\nimport MenuIcon from '@mui/icons-material/Menu';\n\nimport { Settings } from \"../Settings\";\n\nexport const Header = ({ narrow }) => {\n  const navs = [\n  ];\n\n  const [drawerOpen, setDrawerOpen] = React.useState(false);\n\n  const toggleDrawer = (open) => (event) => {\n    if (event.type === 'keydown' && (event.key === 'Tab' || event.key === 'Shift')) {\n      return;\n    }\n\n    setDrawerOpen(open);\n  };\n\n  return (\n    <Box\n      sx={{\n        height: \"52px\",\n        display: \"flex\",\n        bgcolor: \"action.disabledBackground\",\n        overflow: \"auto\",\n      }}\n    >\n      <Box sx={{flexGrow: 1, minWidth: \"36px\"}}></Box>\n      <Settings narrow={narrow}/>\n    </Box>\n  );\n};\n","import { PublicKey, AccountInfo } from '@solana/web3.js';\n\nexport type StringPublicKey = string;\n\nexport class LazyAccountInfoProxy<T> {\n  executable: boolean = false;\n  owner: StringPublicKey = '';\n  lamports: number = 0;\n\n  get data() {\n    //\n    return undefined as unknown as T;\n  }\n}\n\nexport interface LazyAccountInfo {\n  executable: boolean;\n  owner: StringPublicKey;\n  lamports: number;\n  data: [string, string];\n}\n\nconst PubKeysInternedMap = new Map<string, PublicKey>();\n\nexport const toPublicKey = (key: string | PublicKey) => {\n  if (typeof key !== 'string') {\n    return key;\n  }\n\n  let result = PubKeysInternedMap.get(key);\n  if (!result) {\n    result = new PublicKey(key);\n    PubKeysInternedMap.set(key, result);\n  }\n\n  return result;\n};\n\nexport interface PublicKeyStringAndAccount<T> {\n  pubkey: string;\n  account: AccountInfo<T>;\n}\n\nexport const WRAPPED_SOL_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n\nexport const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\nexport const BPF_UPGRADE_LOADER_ID = new PublicKey('BPFLoaderUpgradeab1e11111111111111111111111');\n\nexport const MEMO_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');\n\nexport const SYSTEM = new PublicKey('11111111111111111111111111111111');\n\nexport const TOKEN_METADATA_PROGRAM_ID = new PublicKey(\"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\");\n\nexport const CANDY_MACHINE_ID = new PublicKey('cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ');\n\nexport const GUMDROP_DISTRIBUTOR_ID = new PublicKey(\"gdrpGjVffourzkdDRrQmySw4aTHr8a3xmQzzxSwFD1a\");\n\nexport const GUMDROP_TEMPORAL_SIGNER = new PublicKey(\"MSv9H2sMceAzccBganUXwGq3GXgqYAstmZAbFDZYbAV\");\n\n","import React from \"react\";\nimport { Modal } from \"antd\";\n\nimport \"./index.css\";\n\nexport const DefaultModal = (props: any) => {\n  const { children, closeIcon, bodyStyle, width, style, ...rest } = props;\n\n  return (\n    <Modal\n      style={{ background: \"transparent\", borderRadius: 16 }}\n      bodyStyle={{\n        background: \"#333333\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        ...bodyStyle,\n      }}\n      footer={null}\n      width={\n        width || 400\n      }\n      {...rest}\n    >\n      {children}\n    </Modal>\n  );\n};\n","import { WalletAdapter, WalletError } from \"@solana/wallet-adapter-base\";\nimport {\n  useWallet,\n  WalletProvider as BaseWalletProvider,\n} from \"@solana/wallet-adapter-react\";\nimport {\n  getLedgerWallet,\n  getMathWallet,\n  getPhantomWallet,\n  getSolflareWallet,\n  getSolletWallet,\n  getSolongWallet,\n  getTorusWallet,\n} from \"@solana/wallet-adapter-wallets\";\nimport { Button } from \"antd\";\nimport React, {\n  createContext,\n  FC,\n  ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { notify } from \"../../utils\";\nimport { DefaultModal } from \"../../components\";\n\nimport \"./wallet.less\";\n\nexport interface WalletModalContextState {\n  visible: boolean;\n  setVisible: (open: boolean) => void;\n}\n\nexport const WalletModalContext = createContext<WalletModalContextState>(\n  {} as WalletModalContextState\n);\n\nexport function useWalletModal(): WalletModalContextState {\n  return useContext(WalletModalContext);\n}\n\nexport const WalletModal: FC = () => {\n  const { wallets, wallet: selected, select } = useWallet();\n  const { visible, setVisible } = useWalletModal();\n  const [ , setShowWallets] = useState(false);\n  const close = useCallback(() => {\n    setVisible(false);\n    setShowWallets(false);\n  }, [setVisible, setShowWallets]);\n\n  return (\n    <DefaultModal visible={visible} onCancel={close}>\n      <div\n        style={{\n          background:\n            \"linear-gradient(180deg, #D329FC 0%, #8F6DDE 49.48%, #19E6AD 100%)\",\n          borderRadius: 36,\n          width: 50,\n          height: 50,\n          textAlign: \"center\",\n          verticalAlign: \"middle\",\n          fontWeight: 700,\n          fontSize: \"1.3rem\",\n          lineHeight: 2.4,\n          marginBottom: 10,\n        }}\n      ></div>\n      <h2\n        style={{\n          color: \"white\",\n          fontWeight: \"bold\",\n          fontSize: \"1.2rem\",\n        }}\n      >\n        {selected ? \"Change provider\" : \"\"}\n      </h2>\n      <p style={{ color: \"white\", fontSize: \"1rem\"}}>\n        {selected\n          ? \"Choose from the following options:\"\n          : \"Please sign into your wallet\"}\n      </p>\n\n      <br />\n      {wallets.map((wallet) => {\n        return (\n          <Button\n            key={wallet.name}\n            size=\"large\"\n            type={wallet === selected ? \"primary\" : \"ghost\"}\n            onClick={() => {\n              select(wallet.name);\n              close();\n            }}\n            icon={\n              <img\n                alt={`${wallet.name}`}\n                width={20}\n                height={20}\n                src={wallet.icon}\n                style={{ marginRight: 30, float: \"left\" }}\n              />\n            }\n            style={{\n              display: \"block\",\n              width: \"100%\",\n              textAlign: \"left\",\n              marginBottom: 8,\n              color: \"white\",\n            }}\n          >\n            {wallet.name}\n          </Button>\n        );\n      })}\n    </DefaultModal>\n  );\n};\n\nexport const WalletModalProvider: FC<{ children: ReactNode }> = ({\n  children,\n}) => {\n  const { publicKey } = useWallet();\n  const [connected, setConnected] = useState(!!publicKey);\n  const [visible, setVisible] = useState(false);\n\n  useEffect(() => {\n    if (publicKey) {\n      const base58 = publicKey.toBase58();\n      const keyToDisplay =\n        base58.length > 20\n          ? `${base58.substring(0, 7)}.....${base58.substring(\n              base58.length - 7,\n              base58.length\n            )}`\n          : base58;\n\n      notify({\n        message: \"Wallet update\",\n        description: \"Connected to wallet \" + keyToDisplay,\n      });\n    }\n  }, [publicKey]);\n\n  useEffect(() => {\n    if (!publicKey && connected) {\n      notify({\n        message: \"Wallet update\",\n        description: \"Disconnected from wallet\",\n      });\n    }\n    setConnected(!!publicKey);\n  }, [publicKey, connected, setConnected]);\n\n  return (\n    <WalletModalContext.Provider\n      value={{\n        visible,\n        setVisible,\n      }}\n    >\n      {children}\n      <WalletModal />\n    </WalletModalContext.Provider>\n  );\n};\n\nexport const WalletProvider: FC<{ children: ReactNode }> = ({ children }) => {\n  const wallets = useMemo(\n    () => [\n      getPhantomWallet(),\n      getSolflareWallet(),\n      getTorusWallet({\n        options: {\n          clientId:\n            \"BEB_D44HovHuXH0Ace97QVqSu1ahCKndjpGhzhVcMy_9XmDTbHyqTbzQTufcyaN0kFwtlVbfPzJwpJXg94gWJqE\",\n          uxMode: \"redirect\",\n        },\n      }),\n      getLedgerWallet(),\n      getSolongWallet(),\n      getMathWallet(),\n      getSolletWallet(),\n    ],\n    []\n  );\n\n  const onError = useCallback((error: WalletError) => {\n    console.error(error);\n    notify({\n      message: \"Wallet error\",\n      description: error.message,\n    });\n  }, []);\n\n  return (\n    <BaseWalletProvider wallets={wallets} onError={onError} autoConnect>\n      <WalletModalProvider>{children}</WalletModalProvider>\n    </BaseWalletProvider>\n  );\n};\n\nexport type WalletSigner = Pick<\n  WalletAdapter,\n  \"publicKey\" | \"signTransaction\" | \"signAllTransactions\"\n>;\n","export default __webpack_public_path__ + \"static/media/wallet.c746d144.less\";","import React, { useState, useContext, useCallback } from 'react';\n\nimport { WalletModal } from './WalletContext/WalletContext';\n\nexport enum ModalEnum {\n  WALLET = 'wallet',\n}\n\ntype ModalContextProps = {\n  setModal: (modal: ModalEnum | undefined) => void;\n  removeModal: () => void;\n};\n\nexport const ModalContext = React.createContext<ModalContextProps>({\n  setModal: () => null,\n  removeModal: () => null,\n});\n\nexport const ModalProvider: React.FC = ({ children }) => {\n  const [modal, setModal] = useState<ModalEnum | undefined>(undefined);\n\n  const removeModal = useCallback(() => {\n    setModal(undefined);\n  }, [setModal]);\n\n  return (\n    <ModalContext.Provider\n      value={{\n        setModal,\n        removeModal,\n      }}\n    >\n      {children}\n      {modal === ModalEnum.WALLET && <WalletModal />}\n    </ModalContext.Provider>\n  );\n};\n\nexport const useModal = (): ModalContextProps => {\n  const context = useContext(ModalContext);\n  if (context === undefined) {\n    throw new Error('useModal must be used within a ModalProvider');\n  }\n  return context;\n};\n","import { useTheme } from \"@mui/material\";\nimport React, { useContext } from \"react\";\n\nexport const ColorModeContext = React.createContext({});\n\nexport const ColorModeContextProvider = ({children=null as any }) => {\n  const [mode, setMode] = React.useState<'light' | 'dark'>('dark'); \n  const theme = useTheme();\n  const toggleColorMode = () => {\n    setMode((prevMode) => (prevMode === 'light' ? 'dark' : 'light'));\n  }\n  return (\n    <ColorModeContext.Provider\n      value={{\n        toggleColorMode,\n        mode,\n        theme,\n      }}\n    >\n      {children}\n    </ColorModeContext.Provider>\n  );\n};\n\nexport const useColorMode = (): any => {\n  const context = useContext(ColorModeContext);\n  return context;\n};\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport {\n  AccountsProvider,\n  WalletProvider,\n  ConnectionProvider,\n  ColorModeContextProvider,\n} from \"./contexts\";\n\nimport \"antd/dist/antd.css\";\nimport \"@fontsource/open-sans\";\nimport \"@fontsource/roboto\";\nimport \"@fontsource/sora\";\n\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <ConnectionProvider>\n      <WalletProvider>\n        <AccountsProvider>\n          <ColorModeContextProvider>\n            <App />\n          </ColorModeContextProvider>\n        </AccountsProvider>\n      </WalletProvider>\n    </ConnectionProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\nreportWebVitals();\n","import BN from 'bn.js';\n\nexport const TEN = new BN(10);\nexport const HALF_WAD = TEN.pow(new BN(18));\nexport const WAD = TEN.pow(new BN(18));\nexport const RAY = TEN.pow(new BN(27));\nexport const ZERO = new BN(0);\n","import { useCallback, useState } from 'react';\nimport { MintInfo } from '@solana/spl-token';\n\nimport { TokenAccount } from './../models';\nimport { PublicKey } from '@solana/web3.js';\nimport BN from 'bn.js';\nimport { WAD, ZERO } from '../constants';\nimport { TokenInfo } from '@solana/spl-token-registry';\n\nexport type KnownTokenMap = Map<string, TokenInfo>;\n\nexport const formatPriceNumber = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 8,\n});\n\nexport function useLocalStorageState(key: string, defaultState?: string) {\n  const [state, setState] = useState(() => {\n    // NOTE: Not sure if this is ok\n    const storedState = localStorage.getItem(key);\n    if (storedState) {\n      return JSON.parse(storedState);\n    }\n    return defaultState;\n  });\n\n  const setLocalStorageState = useCallback(\n    newState => {\n      const changed = state !== newState;\n      if (!changed) {\n        return;\n      }\n      setState(newState);\n      if (newState === null) {\n        localStorage.removeItem(key);\n      } else {\n        try {\n          localStorage.setItem(key, JSON.stringify(newState));\n        } catch {\n          // ignore\n        }\n      }\n    },\n    [state, key],\n  );\n\n  return [state, setLocalStorageState];\n}\n\nexport const findProgramAddress = async (\n  seeds: (Buffer | Uint8Array)[],\n  programId: PublicKey,\n) => {\n  const key =\n    'pda-' +\n    seeds.reduce((agg, item) => agg + item.toString('hex'), '') +\n    programId.toString();\n  let cached = localStorage.getItem(key);\n  if (cached) {\n    const value = JSON.parse(cached);\n\n    return [value.key, parseInt(value.nonce)] as [string, number];\n  }\n\n  const result = await PublicKey.findProgramAddress(seeds, programId);\n\n  try {\n    localStorage.setItem(\n      key,\n      JSON.stringify({\n        key: result[0].toBase58(),\n        nonce: result[1],\n      }),\n    );\n  } catch {\n    // ignore\n  }\n\n  return [result[0].toBase58(), result[1]] as [string, number];\n};\n\n// shorten the checksummed version of the input address to have 4 characters at start and end\nexport function shortenAddress(address: string, chars = 4): string {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n}\n\nexport function getTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownSymbol = map.get(mintAddress)?.symbol;\n  if (knownSymbol) {\n    return knownSymbol;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\nexport function getVerboseTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true,\n): string {\n  const mintAddress = typeof mint === 'string' ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return 'N/A';\n  }\n\n  const knownName = map.get(mintAddress)?.name;\n  if (knownName) {\n    return knownName;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\n\nexport function getTokenByName(tokenMap: KnownTokenMap, name: string) {\n  let token: TokenInfo | null = null;\n  for (const val of tokenMap.values()) {\n    if (val.symbol === name) {\n      token = val;\n      break;\n    }\n  }\n  return token;\n}\n\nexport function getTokenIcon(\n  map: KnownTokenMap,\n  mintAddress?: string | PublicKey,\n): string | undefined {\n  const address =\n    typeof mintAddress === 'string' ? mintAddress : mintAddress?.toBase58();\n  if (!address) {\n    return;\n  }\n\n  return map.get(address)?.logoURI;\n}\n\nexport function isKnownMint(map: KnownTokenMap, mintAddress: string) {\n  return !!map.get(mintAddress);\n}\n\nexport const STABLE_COINS = new Set(['USDC', 'wUSDC', 'USDT']);\n\nexport function chunks<T>(array: T[], size: number): T[][] {\n  return Array.apply(\n    0,\n    new Array(Math.ceil(array.length / size)),\n  ).map((_, index) => array.slice(index * size, (index + 1) * size));\n}\n\nexport function toLamports(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  return Math.floor(amount * precision);\n}\n\nexport function wadToLamports(amount?: BN): BN {\n  return amount?.div(WAD) || ZERO;\n}\n\nexport function fromLamports(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount = Math.floor(\n    typeof account === 'number'\n      ? account\n      : BN.isBN(account)\n      ? account.toNumber()\n      : account.info.amount.toNumber(),\n  );\n\n  const precision = Math.pow(10, mint?.decimals || 9);\n  return (amount / precision) * rate;\n}\n\nexport const tryParseKey = (key: string): PublicKey | null => {\n  try {\n    return new PublicKey(key);\n  } catch (error) {\n    return null;\n  }\n};\n\nvar SI_SYMBOL = ['', 'k', 'M', 'G', 'T', 'P', 'E'];\n\nconst abbreviateNumber = (number: number, precision: number) => {\n  let tier = (Math.log10(number) / 3) | 0;\n  let scaled = number;\n  let suffix = SI_SYMBOL[tier];\n  if (tier !== 0) {\n    let scale = Math.pow(10, tier * 3);\n    scaled = number / scale;\n  }\n\n  return scaled.toFixed(precision) + suffix;\n};\n\nexport const formatAmount = (\n  val: number,\n  precision: number = 2,\n  abbr: boolean = true,\n) => (abbr ? abbreviateNumber(val, precision) : val.toFixed(precision));\n\nexport function formatTokenAmount(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0,\n  prefix = '',\n  suffix = '',\n  precision = 2,\n  abbr = false,\n): string {\n  if (!account) {\n    return '';\n  }\n\n  return `${[prefix]}${formatAmount(\n    fromLamports(account, mint, rate),\n    precision,\n    abbr,\n  )}${suffix}`;\n}\n\nexport const formatUSD = new Intl.NumberFormat('en-US', {\n  style: 'currency',\n  currency: 'USD',\n});\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const formatNumber = {\n  format: (val?: number) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n};\n\nexport const formatPct = new Intl.NumberFormat('en-US', {\n  style: 'percent',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport function convert(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n  rate: number = 1.0,\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === 'number' ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  let result = (amount / precision) * rate;\n\n  return result;\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n"],"sourceRoot":""}